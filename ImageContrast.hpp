/**
*
*    Created by ZQJ, 2016.6.12 ‏‎9:23:11 PM.
*    Copyright (c) 2016, 228812066@qq.com All Rights Reserved.
*
*                                       .....'',;;::cccllllllllllllcccc:::;;,,,''...'',,'..
*                            ..';cldkO00KXNNNNXXXKK000OOkkkkkxxxxxddoooddddddxxxxkkkkOO0XXKx:.
*                      .':ok0KXXXNXK0kxolc:;;,,,,,,,,,,,;;,,,''''''',,''..              .'lOXKd'
*                 .,lx00Oxl:,'............''''''...................    ...,;;'.             .oKXd.
*              .ckKKkc'...'',:::;,'.........'',;;::::;,'..........'',;;;,'.. .';;'.           'kNKc.
*           .:kXXk:.    ..       ..................          .............,:c:'...;:'.         .dNNx.
*          :0NKd,          .....''',,,,''..               ',...........',,,'',,::,...,,.        .dNNx.
*         .xXd.         .:;'..         ..,'             .;,.               ...,,'';;'. ...       .oNNo
*         .0K.         .;.              ;'              ';                      .'...'.           .oXX:
*        .oNO.         .                 ,.              .     ..',::ccc:;,..     ..                lXX:
*       .dNX:               ......       ;.                'cxOKK0OXWWWWWWWNX0kc.                    :KXd.
*     .l0N0;             ;d0KKKKKXK0ko:...              .l0X0xc,...lXWWWWWWWWKO0Kx'                   ,ONKo.
*   .lKNKl...'......'. .dXWN0kkk0NWWWWWN0o.            :KN0;.  .,cokXWWNNNNWNKkxONK: .,:c:.      .';;;;:lk0XXx;
*  :KN0l';ll:'.         .,:lodxxkO00KXNWWWX000k.       oXNx;:okKX0kdl:::;'',;coxkkd, ...'. ...'''.......',:lxKO:.
* oNNk,;c,'',.                      ...;xNNOc,.         ,d0X0xc,.     .dOd,           ..;dOKXK00000Ox:.   ..''dKO,
*'KW0,:,.,:..,oxkkkdl;'.                'KK'              ..           .dXX0o:'....,:oOXNN0d;.'. ..,lOKd.   .. ;KXl.
*;XNd,;  ;. l00kxoooxKXKx:..ld:         ;KK'                             .:dkO000000Okxl;.   c0;      :KK;   .  ;XXc
*'XXdc.  :. ..    '' 'kNNNKKKk,      .,dKNO.                                   ....       .'c0NO'      :X0.  ,.  xN0.
*.kNOc'  ,.      .00. ..''...      .l0X0d;.             'dOkxo;...                    .;okKXK0KNXx;.   .0X:  ,.  lNX'
* ,KKdl  .c,    .dNK,            .;xXWKc.                .;:coOXO,,'.......       .,lx0XXOo;...oNWNXKk:.'KX;  '   dNX.
*  :XXkc'....  .dNWXl        .';l0NXNKl.          ,lxkkkxo' .cK0.          ..;lx0XNX0xc.     ,0Nx'.','.kXo  .,  ,KNx.
*   cXXd,,;:, .oXWNNKo'    .'..  .'.'dKk;        .cooollox;.xXXl     ..,cdOKXXX00NXc.      'oKWK'     ;k:  .l. ,0Nk.
*    cXNx.  . ,KWX0NNNXOl'.           .o0Ooldk;            .:c;.':lxOKKK0xo:,.. ;XX:   .,lOXWWXd.      . .':,.lKXd.
*     lXNo    cXWWWXooNWNXKko;'..       .lk0x;       ...,:ldk0KXNNOo:,..       ,OWNOxO0KXXNWNO,        ....'l0Xk,
*     .dNK.   oNWWNo.cXK;;oOXNNXK0kxdolllllooooddxk00KKKK0kdoc:c0No        .'ckXWWWNXkc,;kNKl.          .,kXXk,
*      'KXc  .dNWWX;.xNk.  .kNO::lodxkOXWN0OkxdlcxNKl,..        oN0'..,:ox0XNWWNNWXo.  ,ONO'           .o0Xk;
*      .ONo    oNWWN0xXWK, .oNKc       .ONx.      ;X0.          .:XNKKNNWWWWNKkl;kNk. .cKXo.           .ON0;
*      .xNd   cNWWWWWWWWKOkKNXxl:,'...;0Xo'.....'lXK;...',:lxk0KNWWWWNNKOd:..   lXKclON0:            .xNk.
*      .dXd   ;XWWWWWWWWWWWWWWWWWWNNNNNWWNNNNNNNNNWWNNNNNNWWWWWNXKNNk;..        .dNWWXd.             cXO.
*      .xXo   .ONWNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNK0ko:'..OXo          'l0NXx,              :KK,
*      .OXc    :XNk0NWXKNWWWWWWWWWWWWWWWWWWWWWNNNX00NNx:'..       lXKc.     'lONN0l.              .oXK:
*      .KX;    .dNKoON0;lXNkcld0NXo::cd0NNO:;,,'.. .0Xc            lXXo..'l0NNKd,.              .c0Nk,
*      :XK.     .xNX0NKc.cXXl  ;KXl    .dN0.       .0No            .xNXOKNXOo,.               .l0Xk;.
*     .dXk.      .lKWN0d::OWK;  lXXc    .OX:       .ONx.     . .,cdk0XNXOd;.   .'''....;c:'..;xKXx,
*     .0No         .:dOKNNNWNKOxkXWXo:,,;ONk;,,,,,;c0NXOxxkO0XXNXKOdc,.  ..;::,...;lol;..:xKXOl.
*     ,XX:             ..';cldxkOO0KKKXXXXXXXXXXKKKKK00Okxdol:;'..   .';::,..':llc,..'lkKXkc.
*     :NX'    .     ''            ..................             .,;:;,',;ccc;'..'lkKX0d;.
*     lNK.   .;      ,lc,.         ................        ..,,;;;;;;:::,....,lkKX0d:.
*    .oN0.    .'.      .;ccc;,'....              ....'',;;;;;;;;;;'..   .;oOXX0d:.
*    .dN0.      .;;,..       ....                ..''''''''....     .:dOKKko;.
*     lNK'         ..,;::;;,'.........................           .;d0X0kc'.
*     .xXO'                                                 .;oOK0x:.
*      .cKKo.                                    .,:oxkkkxk0K0xc'.
*        .oKKkc,.                         .';cok0XNNNX0Oxoc,.
*          .;d0XX0kdlc:;,,,',,,;;:clodkO0KK0Okdl:,'..
*              .,coxO0KXXXXXXXKK0OOxdoc:,..
*                        ...
*/

#ifndef IMAGECONTRAST_HPP
#define IMAGECONTRAST_HPP

//#include <stdlib.h>
//#include <stdio.h>
//#include <math.h>
//#include <fstream>
//#include <string>
#include <iostream>
#include <opencv/cv.hpp>
#include <opencv/highgui.h> 
#include <math.h>

class ImgCon
{
private:
	cv::Mat m0, m1;
	int channels;
	int w, h;
	//bool h_w_bin0[1000][1000][24];		//图像大小限制
	//bool h_w_bin1[1000][1000][24];		//图像大小限制
	bool ***h_w_bin0;
	bool ***h_w_bin1;
	
	//存储haar特征值
	//int haar_val0[1000][1000][12];
	//int haar_val1[1000][1000][12];
	int ***haar_val0;
	int ***haar_val1;

	bool bin(int x, int y);			//x>=y返回1，否则0
	bool p_isinimg(CvPoint p, cv::Mat* m);		//判断一个点是否在图片内部
	bool notinvec(std::vector<CvPoint> vec, CvPoint p);		//不在容器内
	std::vector<std::vector<CvPoint>> outlines;	//多个连通区域的轮廓
	int conv(cv::Mat *m, int mode);		//根据图像(m)以及特征类型(mode)做卷积，返回一个int value；
		
	CvPoint cr_centre(std::vector<CvPoint> ps);	//求连通区域中心点（伪中心点，速度快）
	int dist(CvPoint p1, CvPoint p2);	//两个点之间的距离

	//根据一个区域画矩形
	cv::Rect region2R(std::vector<CvPoint> ps);

public:
	//积分图
	//int intgrlimg0[1000][1000];
	//int intgrlimg1[1000][1000];
	int **intgrlimg0;
	int **intgrlimg1;

	//毁伤程度,0-100,无损坏-完全损坏,compare使用haar时才可用,compare后得出
	//int damagelevel[1000][1000];
	//int **damagelevel;

	std::vector<std::vector<CvPoint>> vecs;		//保存多个连通区域的容器


public:
	~ImgCon();
	ImgCon(cv::Mat* img0, cv::Mat* img1);

	void setm0(cv::Mat* m);
	void setm1(cv::Mat* m);

	void debuginfo();

	void compute_h_w_bin(int mode = 0);		//计算h_w_bin两个三维数组,mode!=0:haar
	void compute_haar_val();	//保存到haar_val1[1000][1000][12]

	//0 <= threshold <= 8,计算3通道时*3，越高比较规格越严格,返回一个二值特征图。flag:偏移比较，0-12
	cv::Mat compare(int threshold, int** scoreMap, bool haar = false, int flag = 0);

	std::vector<CvPoint> connectedregion(cv::Mat& m, CvPoint p);		//求连通区域
	void revalregion(cv::Mat& m, std::vector<CvPoint> ps, int val);			//对连通区域重新赋值
	void revalregion_s(cv::Mat& m, int val, int flag = 0);			//对多重连通区域重新赋值
	void findconnectedregions(cv::Mat* m);			//求多个连通区域，保存到vecs
	void findconnectedregions(cv::Mat* m, std::vector<std::vector<CvPoint>> &vs);

	//求主要连通区域，保存到vecs,
	//mode=0:按所有连通区域平均值过滤
	//mode=1:按固定面积滤掉小点
	void findmainregion(int mode=0);	

	cv::Mat vecs2binimg(std::vector<std::vector<CvPoint>> vs);	//根据连通区域生成二值特征图
	void findoutlines(cv::Mat* img, cv::Mat &m, char color, int thickness);	//根据二值图像img找轮廓，画到m上面,只依赖于一个二值图像即可
	cv::Mat feature_and(cv::Mat* m1, cv::Mat* m2);		//特征图求交
	cv::Mat feature_or(cv::Mat* m1, cv::Mat* m2);		//特征图求交

	void integral_img();		//生成积分图，m灰度或彩色，保存到intgrlimg[1000][1000]

	//根据中心点p,核大小kernel，卷积模式mode计算卷积
	//p>=5, kernel:5,7,9,11, mode:1,2,3
	int haar0(CvPoint p, int kernel, int mode);
	int haar1(CvPoint p, int kernel, int mode);
	bool haar0b(CvPoint p, int kernel, int mode);
	bool haar1b(CvPoint p, int kernel, int mode);

	//返回一副二值特征图,参数分别的含义：一个特征值误差多少算相等，多少个特征值相等算改点匹配
	cv::Mat compare_haar(int threshold, int threshold1);

	//去除小点，核越大能去除的小点越大【未写完】
	void clear_small_point(cv::Mat *m, int kernel);

	//整理连通区域，离得近的合并为一个连通区域，返回结果为修改原来的vecs
	void arrange_cr(int threshold);

	//根据多个连通区域和得分图求rect和得分
	void compute_sc(
		std::vector<std::vector<CvPoint>> rs, 
		int **scmp_, 
		std::vector<std::pair<cv::Rect, int>> &res);

};









#endif